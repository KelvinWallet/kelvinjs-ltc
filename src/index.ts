import axios from 'axios';
import * as bech32 from 'bech32';
import * as bs58 from 'bs58';

import { LITECOIN_CMDID } from 'kelvinjs-protob';
import { LtcCommand, LtcResponse } from 'kelvinjs-protob/dist/litecoin_pb';

import {
  ICurrencyUtil,
  IArmadilloCommand,
  IArmadilloResponse,
  ISignTxRequest,
  ITransaction,
  ITransactionSchema,
} from './api';

import { selectUtxos, OutMode } from './selectUtxos';

import * as crypto from 'crypto';

// ---------------------------------------------------------------------------

enum AddrType {
  INVALID,
  MAIN_P2PKH,
  MAIN_P2SH,
  MAIN_P2SH_LEGACY,
  MAIN_P2WPKH,
  MAIN_P2WSH,
  TEST_P2PKH,
  TEST_P2SH,
  TEST_P2SH_LEGACY,
  TEST_P2WPKH,
  TEST_P2WSH,
}

// ---------------------------------------------------------------------------

const { LtcShowAddr, LtcGetXPub, LtcSignTx } = LtcCommand;
const { LtcTxIn, LtcTxOut } = LtcSignTx;

// ---------------------------------------------------------------------------

const MIN_SAT_TO_SEND = 100000; // 0.00100000 LTC
const MAX_SAT_TO_SEND = 99999999999999; // 999,999.99999999 LTC

const DUST_TXOUT_FEE_RATE = 3000; // do not generate such dust txouts
const DISCARD_CHANGE_FEE_RATE = 10000; // do not generate such change txouts

const MIN_FEE_RATE_SAT_PER_KVB = 1000; // fee rate at least 1000 sat per kvb
const MAX_FEE_RATE_SAT_PER_KVB = 10000000; // fee rate at most 0.1 LTC per kvb
const MAX_FEE_TOTAL = 999999999; // total fee at most 9.99999999 LTC

const MAX_TXOUT_IDX = 99999;

// ---------------------------------------------------------------------------

function isString(x: unknown): x is string {
  return typeof x === 'string';
}

function isArray(x: unknown): x is unknown[] {
  return Array.isArray(x);
}

function isNonNegativeInteger(x: unknown): x is number {
  return typeof x === 'number' && Number.isSafeInteger(x) && x >= 0;
}

function isObject(x: unknown): x is { [x: string]: unknown } {
  return typeof x === 'object' && x !== null && !Array.isArray(x);
}

// ---------------------------------------------------------------------------

function isValidTxoutIndex(n: unknown): n is number {
  return isNonNegativeInteger(n) && n <= MAX_TXOUT_IDX;
}

function isValidBlockchainTimestamp(n: unknown): n is number {
  const LOW = 1317972665; // 2011-10-07T07:31:05Z (LTC genesis)
  const UPP = 4102444800; // 2100-01-01T00:00:00Z
  return isNonNegativeInteger(n) && n >= LOW && n <= UPP;
}

function isNonNegativeDecimalStr(s: unknown): s is string {
  return isString(s) && /^(0|[1-9][0-9]*)$/.test(s);
}

function isValidTransactionId(s: unknown): s is string {
  return isString(s) && /^[0-9a-f]{64}$/.test(s);
}

function isValidAmountNum(v: unknown): v is number {
  return isNonNegativeInteger(v) && v <= 84e14;
}

function isValidAmountStr(s: unknown): s is string {
  return (
    isNonNegativeDecimalStr(s) &&
    (s.length <= 15 || (s.length === 16 && s <= '8400000000000000'))
  );
}

function isValidFeeRateToPayNum(v: unknown): v is number {
  return (
    isNonNegativeInteger(v) &&
    v >= MIN_FEE_RATE_SAT_PER_KVB &&
    v <= MAX_FEE_RATE_SAT_PER_KVB
  );
}

function isValidFeeRateToPayStr(s: unknown): s is string {
  return (
    isValidAmountStr(s) &&
    +s >= MIN_FEE_RATE_SAT_PER_KVB &&
    +s <= MAX_FEE_RATE_SAT_PER_KVB
  );
}

// ---------------------------------------------------------------------------

function isValidHexString(s: string): boolean {
  return /^([0-9a-f]{2})*$/.test(s);
}

function isValidPubKey(s: string): boolean {
  // Because we are lazy, we do not actually check whether the provided values
  // (X, Y) is indeed a valid EC point on the curve secp256k1
  return /^04[0-9a-f]{128}$/.test(s);
}

// ---------------------------------------------------------------------------

function sha256(d: Buffer): Buffer {
  return crypto
    .createHash('sha256')
    .update(d)
    .digest();
}

function ripemd160(d: Buffer): Buffer {
  return crypto
    .createHash('ripemd160')
    .update(d)
    .digest();
}

function hash256(d: Buffer): Buffer {
  return sha256(sha256(d));
}

function hash160(d: Buffer): Buffer {
  return ripemd160(sha256(d));
}

// ---------------------------------------------------------------------------

const w = <T>(
  errMsg: string | ((err: unknown) => string),
  genValueOrError: () => T
): T => {
  // Catch error and throw a new error with a specific error message, or just
  // return the value generated by a function call.
  try {
    return genValueOrError();
  } catch (err) {
    if (typeof errMsg === 'string') {
      throw Error(errMsg);
    } else {
      throw Error(errMsg(err));
    }
  }
};

// ---------------------------------------------------------------------------

function decodeBase58checkAddress(h: string): [number, Buffer] {
  if (!(h.length <= 99)) {
    throw Error('invalid input');
  }
  const b = w('invalid input', () => bs58.decode(h));
  if (!(b.length >= 5)) {
    throw Error('invalid input');
  }
  const versionAndData = b.slice(0, b.length - 4);
  const providedChecksum = b.slice(b.length - 4);
  const computedCheckSum = hash256(versionAndData).slice(0, 4);
  if (
    !(
      providedChecksum[0] === computedCheckSum[0] &&
      providedChecksum[1] === computedCheckSum[1] &&
      providedChecksum[2] === computedCheckSum[2] &&
      providedChecksum[3] === computedCheckSum[3]
    )
  ) {
    throw Error('invalid input');
  }
  const versionByteValue = versionAndData[0];
  const encodedPayloadBytes = versionAndData.slice(1);
  if (!(encodedPayloadBytes.length === 20)) {
    throw Error('invalid input');
  }
  return [versionByteValue, encodedPayloadBytes];
}

function decodeBech32Address(inputAddr: string): [string, Buffer] {
  const result = bech32.decode(inputAddr);
  if (!(result.words.length >= 1)) {
    throw Error('invalid input');
  }
  const witnessVersion = result.words[0];
  if (!(witnessVersion === 0)) {
    throw Error('invalid input');
  }
  const witnessProgramBytes = bech32.fromWords(result.words.slice(1));
  if (
    !(witnessProgramBytes.length === 20 || witnessProgramBytes.length === 32)
  ) {
    throw Error('invalid input');
  }
  const hrp = result.prefix;
  return [hrp, witnessProgramBytes];
}

function decodeBase58checkAddressNoException(
  h: string,
  errorVer: number = 0xff
): [number, Buffer] {
  try {
    return decodeBase58checkAddress(h);
  } catch (_) {
    return [errorVer, Buffer.from([])];
  }
}

function decodeBech32AddressNoException(
  inputAddr: string,
  errorHrp: string = 'ERROR'
): [string, Buffer] {
  try {
    return decodeBech32Address(inputAddr);
  } catch (_) {
    return [errorHrp, Buffer.from([])];
  }
}

function decodeLtcAddr(addr: string): [AddrType, Buffer] {
  const [ver, b58content] = decodeBase58checkAddressNoException(addr);
  const [hrp, b32content] = decodeBech32AddressNoException(addr);
  const b58len = b58content.length;
  const b32len = b32content.length;

  // mainnet base58 addresses
  if (ver === 0x30 && b58len === 20) {
    return [AddrType.MAIN_P2PKH, b58content];
  }
  if (ver === 0x32 && b58len === 20) {
    return [AddrType.MAIN_P2SH, b58content];
  }
  if (ver === 0x05 && b58len === 20) {
    return [AddrType.MAIN_P2SH_LEGACY, b58content];
  }

  // testnet base58 addresses
  if (ver === 0x6f && b58len === 20) {
    return [AddrType.TEST_P2PKH, b58content];
  }
  if (ver === 0x3a && b58len === 20) {
    return [AddrType.TEST_P2SH, b58content];
  }
  if (ver === 0xc4 && b58len === 20) {
    return [AddrType.TEST_P2SH_LEGACY, b58content];
  }

  // mainnet bech32 addresses
  if (hrp === 'ltc' && b32len === 20) {
    return [AddrType.MAIN_P2WPKH, b32content];
  }
  if (hrp === 'ltc' && b32len === 32) {
    return [AddrType.MAIN_P2WSH, b32content];
  }

  // testnet bech32 addresses
  if (hrp === 'tltc' && b32len === 20) {
    return [AddrType.TEST_P2WPKH, b32content];
  }
  if (hrp === 'tltc' && b32len === 32) {
    return [AddrType.TEST_P2WSH, b32content];
  }

  return [AddrType.INVALID, Buffer.from([])];
}

function modernizeLtcAddr(addr: string): string {
  const [addrType, content] = decodeLtcAddr(addr);
  if (addrType === AddrType.MAIN_P2SH_LEGACY) {
    return encodeBase58check(0x32, content); // change ver from 0x05 to 0x32
  }
  if (addrType === AddrType.TEST_P2SH_LEGACY) {
    return encodeBase58check(0x3a, content); // change ver from 0xc4 to 0x3a
  }
  return addr;
}

// ---------------------------------------------------------------------------

function truncateToSixDecimals(x: string): string {
  const regexMatch = x.match(/^.*\..{6}/);
  if (regexMatch !== null) {
    return regexMatch[0];
  }
  return x;
}

// ---------------------------------------------------------------------------

function compressPubKey(input: Buffer): Buffer {
  if (!(input.length === 65 && input[0] === 0x04)) {
    throw Error(`invalid input ${input.toString('hex')}`);
  }
  return Buffer.concat([
    Buffer.from([0x02 + (input[64] & 0x01)]),
    input.slice(1, 1 + 32),
  ]);
}

function encodeBase58check(ver: number, data: Buffer): string {
  if (!(Number.isInteger(ver) && ver >= 0x00 && ver <= 0xff)) {
    throw Error(`invalid ver: ${ver}`);
  }
  const a = Buffer.concat([Buffer.from([ver]), data]);
  const b = hash256(a).slice(0, 4);
  const c = Buffer.concat([a, b]);
  return bs58.encode(c);
}

function encodePubkeyToAddrP2SH(network: string, pubkey: string): string {
  if (!['mainnet', 'testnet'].includes(network)) {
    throw Error(`invalid network: ${network}`);
  }

  if (!isValidPubKey(pubkey)) {
    throw Error(`invalid pubkey: ${pubkey}`);
  }

  const pubkeyBuf = compressPubKey(Buffer.from(pubkey, 'hex'));
  const pubkeyHash = hash160(pubkeyBuf);
  const redeemScript = Buffer.concat([Buffer.from([0x00, 0x14]), pubkeyHash]);
  const scriptHash = hash160(redeemScript);
  const verByte = network === 'mainnet' ? 0x32 : 0x3a; // legacy: 0x05 0xc4
  return encodeBase58check(verByte, scriptHash);
}

// ---------------------------------------------------------------------------

async function performMyGet({
  endpoint,
  path,
  timeoutMs,
}: {
  endpoint: string;
  path: string;
  timeoutMs: number;
}): Promise<{ statusCode: number; payload: unknown }> {
  const { status, data } = await axios({
    baseURL: endpoint,
    url: path,
    timeout: timeoutMs,
    validateStatus: () => true,
  });
  return {
    statusCode: status,
    payload: data,
  };
}

async function performMyPost({
  endpoint,
  path,
  timeoutMs,
  payload,
}: {
  endpoint: string;
  path: string;
  timeoutMs: number;
  payload: unknown;
}): Promise<{ statusCode: number; payload: unknown }> {
  const { status, data } = await axios({
    method: 'post',
    baseURL: endpoint,
    url: path,
    timeout: timeoutMs,
    data: payload,
    validateStatus: () => true,
  });
  return {
    statusCode: status,
    payload: data,
  };
}

// ---------------------------------------------------------------------------

// Return an array of zero or more [txId, outIdx, value] tuples
async function getUnspentTxOuts(
  network: string,
  addr: string
): Promise<Array<[string, number, number]>> {
  if (!['mainnet', 'testnet'].includes(network)) {
    throw Error(`invalid network: ${network}`);
  }

  if (!isValidAddr(network, addr)) {
    throw Error(`not a valid address: ${addr}`);
  }

  if (network === 'mainnet') {
    const { statusCode, payload } = await performMyGet({
      endpoint: 'https://api.blockcypher.com',
      path: `/v1/ltc/main/addrs/${addr}?unspentOnly=1`,
      timeoutMs: 5000,
    });

    // check response status code
    if (statusCode !== 200) {
      throw Error(`unexpected HTTP statusCode: ${statusCode}`);
    }

    // check response payload
    if (
      !((
        x: unknown
      ): x is {
        txrefs: Array<{
          tx_hash: string;
          tx_output_n: number;
          value: number;
        }>;
      } =>
        isObject(x) &&
        isArray(x.txrefs) &&
        x.txrefs.every(
          (e: unknown) =>
            isObject(e) &&
            isValidTransactionId(e.tx_hash) &&
            isValidTxoutIndex(e.tx_output_n) &&
            isValidAmountNum(e.value)
        ))(payload)
    ) {
      throw Error(`unexpected HTTP response: ${payload}`);
    }

    return payload.txrefs.map(e => [e.tx_hash, e.tx_output_n, e.value]);
  } else {
    const { statusCode, payload } = await performMyGet({
      endpoint: 'https://testnet.litecore.io',
      path: `/api/addr/${addr}/utxo`,
      timeoutMs: 5000,
    });

    // check response status code
    if (statusCode !== 200) {
      throw Error(`unexpected HTTP statusCode: ${statusCode}`);
    }

    // check response payload
    if (
      !((
        x: unknown
      ): x is Array<{
        txid: string;
        vout: number;
        satoshis: number;
      }> =>
        isArray(x) &&
        x.every(
          (e: unknown) =>
            isObject(e) &&
            isValidTransactionId(e.txid) &&
            isValidTxoutIndex(e.vout) &&
            isValidAmountNum(e.satoshis)
        ))(payload)
    ) {
      throw Error(`unexpected HTTP response: ${payload}`);
    }

    return payload.map(e => [e.txid, e.vout, e.satoshis]);
  }
}

// ---------------------------------------------------------------------------

function getSupportedNetworks(): string[] {
  return ['mainnet', 'testnet'];
}

function getFeeOptionUnit(): string {
  return 'sat/kB';
}

function isValidFeeOption(network: string, feeOpt: string): boolean {
  if (!['mainnet', 'testnet'].includes(network)) {
    throw Error(`invalid network: ${network}`);
  }
  return isValidFeeRateToPayStr(feeOpt);
}

function isValidAddr(network: string, addr: string): boolean {
  const ltcAddrType = decodeLtcAddr(addr)[0];
  if (network === 'mainnet') {
    return [
      AddrType.MAIN_P2PKH,
      AddrType.MAIN_P2SH,
      AddrType.MAIN_P2SH_LEGACY,
      AddrType.MAIN_P2WPKH,
      AddrType.MAIN_P2WSH,
    ].includes(ltcAddrType);
  } else if (network === 'testnet') {
    return [
      AddrType.TEST_P2PKH,
      AddrType.TEST_P2SH,
      AddrType.TEST_P2SH_LEGACY,
      AddrType.TEST_P2WPKH,
      AddrType.TEST_P2WSH,
    ].includes(ltcAddrType);
  } else {
    throw Error(`invalid network: ${network}`);
  }
}

function isValidNormAmount(amount: string): boolean {
  // 0
  // 1
  // 9
  // 19
  // 1000
  // 1000000
  // 55000000
  // 84000000
  // 0.
  // 0.1
  // 0.12
  // 0.777777777777
  // 84000000.00000000
  if (!/^(0|[1-9][0-9]*)(\.[0-9]*)?$/.test(amount)) {
    return false;
  }

  // because a satoshi is not divisible, the following cases are invalid
  // a. there is an dot in the string
  // b. the part after the dot is longer than 8 characters
  // c. there is a nonzero digit after the 8th decimal place
  if (amount.includes('.')) {
    const fractPart = amount.slice(amount.indexOf('.') + 1);
    if (fractPart.length > 8) {
      const afterThe8thDecimalPlace = fractPart.slice(8);
      if (!/^0+$/.test(afterThe8thDecimalPlace)) {
        return false;
      }
    }
  }

  // invalid if greater than 84000000.00000000 LTC
  const wholePart = amount.replace(/\..*$/, '');
  if (
    wholePart.length >= 9 ||
    (wholePart.length === 8 && wholePart > '84000000') ||
    (wholePart === '84000000' && /\..*[1-9]/.test(amount))
  ) {
    return false;
  }

  return true;
}

function convertNormAmountToBaseAmount(amount: string): string {
  if (!isValidNormAmount(amount)) {
    throw Error(`invalid LTC amount: ${amount}`);
  }
  const wholePart = amount.replace(/\..*$/, '');
  const fractPart = amount
    .replace(/^.*\.|^[0-9]$/, '')
    .padEnd(8, '0')
    .slice(0, 8);
  return (wholePart + fractPart).replace(/^0+/, '').padStart(1, '0');
}

function convertBaseAmountToNormAmount(amount: string): string {
  if (!isValidAmountStr(amount)) {
    throw Error(`invalid satoshi amount: ${amount}`);
  }
  const zeroPaddedSatoshis = amount.padStart(16, '0');
  const wholeNumberPart = zeroPaddedSatoshis.slice(0, 8);
  const fractNumberPart = zeroPaddedSatoshis.slice(8);
  const partHead =
    wholeNumberPart === '00000000' ? '0' : wholeNumberPart.replace(/^0+/, '');
  const partTail =
    fractNumberPart === '00000000'
      ? ''
      : '.' + fractNumberPart.replace(/0+$/, '');
  return partHead + partTail;
}

function getUrlForAddr(network: string, addr: string): string {
  if (!['mainnet', 'testnet'].includes(network)) {
    throw Error(`invalid network: ${network}`);
  }
  if (!isValidAddr(network, addr)) {
    throw Error(`not a valid address: ${addr}`);
  }
  if (network === 'mainnet') {
    return `https://blockchair.com/litecoin/address/${addr}`;
  } else {
    return `https://tltc.bitaps.com/${addr}`;
  }
}

function getUrlForTx(network: string, txid: string): string {
  if (!['mainnet', 'testnet'].includes(network)) {
    throw Error(`invalid network: ${network}`);
  }
  if (!isValidTransactionId(txid)) {
    throw Error(`invalid txid: ${txid}`);
  }
  if (network === 'mainnet') {
    return `https://blockchair.com/litecoin/transaction/${txid}`;
  } else {
    return `https://tltc.bitaps.com/${txid}`;
  }
}

function encodePubkeyToAddr(network: string, pubkey: string): string {
  // by default we support P2SH-P2WPKH for Litecoin
  // just as we do for Bitcoin
  if (!['mainnet', 'testnet'].includes(network)) {
    throw Error(`invalid network: ${network}`);
  }
  if (!isValidPubKey(pubkey)) {
    throw Error(`invalid pubkey: ${pubkey}`);
  }
  return encodePubkeyToAddrP2SH(network, pubkey);
}

async function getBalance(network: string, addr: string): Promise<string> {
  if (!['mainnet', 'testnet'].includes(network)) {
    throw Error(`invalid network: ${network}`);
  }

  if (!isValidAddr(network, addr)) {
    throw Error(`not a valid address: ${addr}`);
  }

  if (network === 'mainnet') {
    const { statusCode, payload } = await performMyGet({
      endpoint: 'https://api.blockcypher.com',
      path: `/v1/ltc/main/addrs/${addr}`,
      timeoutMs: 5000,
    });

    // check response status code
    if (statusCode !== 200) {
      throw Error(`unexpected HTTP statusCode: ${statusCode}`);
    }

    // check response payload
    if (
      !((x: unknown): x is { final_balance: number } =>
        isObject(x) && isValidAmountNum(x.final_balance))(payload)
    ) {
      throw Error(`unexpected HTTP response: ${payload}`);
    }

    const balanceBaseUnit = '' + payload.final_balance;
    const balanceNormUnit = convertBaseAmountToNormAmount(balanceBaseUnit);
    return balanceNormUnit;
  } else {
    const { statusCode, payload } = await performMyGet({
      endpoint: 'https://api.bitaps.com',
      path: `/ltc/testnet/v1/blockchain/address/state/${addr}`,
      timeoutMs: 5000,
    });

    // check response status code
    if (statusCode !== 200) {
      throw Error(`unexpected HTTP statusCode: ${statusCode}`);
    }

    // check response payload
    if (
      !((x: unknown): x is { data: { balance: number } } =>
        isObject(x) && isObject(x.data) && isValidAmountNum(x.data.balance))(
        payload
      )
    ) {
      throw Error(`unexpected HTTP response: ${payload}`);
    }

    const balanceBaseUnit = '' + payload.data.balance;
    const balanceNormUnit = convertBaseAmountToNormAmount(balanceBaseUnit);
    return balanceNormUnit;
  }
}

function getHistorySchema(): ITransactionSchema[] {
  return [
    { key: 'txid', label: 'Transaction ID', format: 'hash' },
    { key: 'amount', label: 'Amount', format: 'value' },
    { key: 'date', label: 'Time', format: 'date' },
    { key: 'isConfirmed', label: 'isConfirmed', format: 'boolean' },
  ];
}

async function getRecentHistory(
  network: string,
  addr: string
): Promise<ITransaction[]> {
  if (!['mainnet', 'testnet'].includes(network)) {
    throw Error(`invalid network: ${network}`);
  }

  if (!isValidAddr(network, addr)) {
    throw Error(`not a valid address: ${addr}`);
  }

  const { statusCode, payload } = await performMyGet({
    endpoint: 'https://api.bitaps.com',
    path:
      network === 'mainnet'
        ? `/ltc/v1/blockchain/address/transactions/${addr}`
        : `/ltc/testnet/v1/blockchain/address/transactions/${addr}`,
    timeoutMs: 5000,
  });

  // check response status code
  if (statusCode !== 200) {
    throw Error(`unexpected HTTP statusCode: ${statusCode}`);
  }

  // check response payload
  if (
    !((
      x: unknown
    ): x is {
      data: {
        list: Array<{
          txId: string;
          received: number;
          sent: number;
          confirmations: number;
          timestamp: number;
        }>;
      };
    } =>
      isObject(x) &&
      isObject(x.data) &&
      isArray(x.data.list) &&
      x.data.list.every(
        (e: unknown) =>
          isObject(e) &&
          isValidTransactionId(e.txId) &&
          isValidAmountNum(e.received) &&
          isValidAmountNum(e.sent) &&
          isNonNegativeInteger(e.confirmations) &&
          isValidBlockchainTimestamp(e.timestamp)
      ))(payload)
  ) {
    throw Error(`unexpected HTTP response: ${payload}`);
  }

  const getAmountSummary = (recv: number, sent: number): string => {
    if (recv >= sent) {
      return convertBaseAmountToNormAmount('' + (recv - sent));
    } else {
      return '-' + convertBaseAmountToNormAmount('' + (sent - recv));
    }
  };

  return payload.data.list.map(e => ({
    txid: { value: e.txId, link: getUrlForTx(network, e.txId) },
    amount: { value: getAmountSummary(e.received, e.sent) },
    date: { value: new Date(e.timestamp * 1000).toISOString() },
    isConfirmed: { value: '' + (e.confirmations > 0) },
  }));
}

async function getFeeOptions(network: string): Promise<string[]> {
  if (!['mainnet', 'testnet'].includes(network)) {
    throw Error(`invalid network: ${network}`);
  }

  if (network === 'testnet') {
    return ['1000', '100000', '500000'];
  }

  const { statusCode, payload } = await performMyGet({
    endpoint: 'https://api.blockcypher.com',
    path: '/v1/ltc/main',
    timeoutMs: 5000,
  });

  // check response status code
  if (statusCode !== 200) {
    throw Error(`unexpected HTTP statusCode: ${statusCode}`);
  }

  // check response payload
  if (
    !((
      x: unknown
    ): x is {
      low_fee_per_kb: number;
      medium_fee_per_kb: number;
      high_fee_per_kb: number;
    } =>
      isObject(x) &&
      isValidFeeRateToPayNum(x.low_fee_per_kb) &&
      isValidFeeRateToPayNum(x.medium_fee_per_kb) &&
      isValidFeeRateToPayNum(x.high_fee_per_kb))(payload)
  ) {
    throw Error(`unexpected HTTP response: ${payload}`);
  }

  return [
    '' + payload.low_fee_per_kb,
    '' + payload.medium_fee_per_kb,
    '' + payload.high_fee_per_kb,
  ];
}

function getPreparedTxSchema(): ITransactionSchema[] {
  return [
    { key: 'amount', label: 'Amount', format: 'value' },
    { key: 'to', label: 'To', format: 'address' },
    { key: 'fee', label: 'Fee', format: 'value' },
  ];
}

function validateSignTxRequest(req: ISignTxRequest): void {
  // check obviously incorrect API usage
  if (!['mainnet', 'testnet'].includes(req.network)) {
    throw Error(`invalid network: ${req.network}`);
  }
  if (!(isNonNegativeInteger(req.accountIndex) && req.accountIndex < 2 ** 31)) {
    throw Error(`invalid account index: ${req.accountIndex}`);
  }
  if (!isValidPubKey(req.fromPubkey)) {
    throw Error(`invalid account public key: ${req.fromPubkey}`);
  }

  // check obviously incorrect user inputs
  if (!isValidAddr(req.network, req.toAddr)) {
    throw Error(`not a valid address: ${req.toAddr}`);
  }

  // check send amount (in normal unit)
  if (!isValidNormAmount(req.amount)) {
    throw Error(`not a valid amount to send: ${req.amount}`);
  }
  const t = +convertNormAmountToBaseAmount(req.amount);
  if (!(t >= MIN_SAT_TO_SEND && t <= MAX_SAT_TO_SEND)) {
    throw Error(`not a valid amount to send: ${req.amount}`);
  }

  if (!isValidFeeRateToPayStr(req.feeOpt)) {
    throw Error(`not a valid fee option: ${req.feeOpt}`);
  }

  // Prohibit sending funds back to the same address
  if (
    encodePubkeyToAddrP2SH(req.network, req.fromPubkey) ===
    modernizeLtcAddr(req.toAddr)
  ) {
    throw Error('sending funds back to the same address is prohibited');
  }
}

function validatePreparedTx(preparedTx: IArmadilloCommand): void {
  if (
    !(
      preparedTx.commandId >= 0x0000 &&
      preparedTx.commandId <= 0xffff &&
      preparedTx.payload.length <= 7000
    )
  ) {
    throw Error('the input prepared tx is invalid');
  }
}

async function prepareCommandSignTx(
  req: ISignTxRequest
): Promise<[IArmadilloCommand, ITransaction]> {
  // validate whether the API usage and user input are correct
  validateSignTxRequest(req);

  // Conditionally patch the `toAddr` if the input is in the legacy form
  // 1. mainnet P2SH version byte should be 0x32 instead of legacy 0x05
  // 2. testnet P2SH version byte should be 0x3a instead of legacy 0xc4
  const toAddr = modernizeLtcAddr(req.toAddr);

  // Encode pubkey to P2SH-P2WPKH address for the specified network
  const fromAddr = encodePubkeyToAddrP2SH(req.network, req.fromPubkey);

  // Convert the user input (amount in normal unit) to numeric value in base unit
  const satoshiAmount = +convertNormAmountToBaseAmount(req.amount);

  // Determine the destination address mode for selectUtxos() call
  const [toAddrType, toAddrContent] = decodeLtcAddr(toAddr);
  const outMode = ((x: AddrType): OutMode => {
    switch (x) {
      case AddrType.MAIN_P2PKH:
      case AddrType.TEST_P2PKH:
        return 'P2PKH';
      case AddrType.MAIN_P2SH:
      case AddrType.TEST_P2SH:
        return 'P2SH';
      case AddrType.MAIN_P2WPKH:
      case AddrType.TEST_P2WPKH:
        return 'P2WPKH';
      case AddrType.MAIN_P2WSH:
      case AddrType.TEST_P2WSH:
        return 'P2WSH';
      default:
        throw Error('control reaches a point which shall be unreachable');
    }
  })(toAddrType);

  // Look up UTXOs from the network
  // - the result is an array of [txId, outIdx, value] tuples
  // - the tuple type is [string, number, number]
  const utxos = await getUnspentTxOuts(req.network, fromAddr);

  // Try to select at most 10 UTXOs if the request is fulfillable
  const [selectedUtxoIndices, chgAmount, feeAmount] = selectUtxos(
    utxos.map(x => x[2]),
    'P2SHP2WPKH',
    outMode,
    satoshiAmount,
    +(req.feeOpt || 0), // dirty hack before using ts 3.7 assertion signatures
    DUST_TXOUT_FEE_RATE,
    DISCARD_CHANGE_FEE_RATE
  );

  // Just a safety/sanity check
  if (
    !(
      isValidAmountNum(chgAmount) &&
      isValidAmountNum(feeAmount) &&
      feeAmount <= MAX_FEE_TOTAL
    )
  ) {
    throw Error('failed to build a transaction with reasonable fee option');
  }

  // Here is the selected subset of [txId, outIdx, value] tuples
  const selectedUtxos: Array<
    [string, number, number]
  > = selectedUtxoIndices.map(i => utxos[i]);

  // Placeholder object to encapsluate txins and txouts of this tx request
  const mLtcSignTx = new LtcSignTx();

  // Build inputs
  mLtcSignTx.setInputsList(
    selectedUtxos.map(([txId, outIdx, value]) => {
      // for each select UTXO as input:
      //
      //      path        uint32_t[3]
      //      prev_tid    uint8_t[32]
      //      prev_index  uint64_t
      //      value       uint64_t
      //
      const mLtcTxIn = new LtcTxIn();
      mLtcTxIn.setPathList([2 ** 31 + req.accountIndex, 0, 0]);
      mLtcTxIn.setPrevTid(Buffer.from(txId, 'hex').reverse());
      mLtcTxIn.setPrevIndex(outIdx);
      mLtcTxIn.setValue(value);
      return mLtcTxIn;
    })
  );

  // Build outputs
  // output 0 is for the primary fund recipient
  // output 1 is for change if we have one
  const mLtcTxOut0 = new LtcTxOut();
  const mLtcTxOut1 = new LtcTxOut();
  mLtcTxOut1.setValue(chgAmount);
  mLtcTxOut1.setP2shShash(decodeLtcAddr(fromAddr)[1]);
  mLtcTxOut0.setValue(satoshiAmount);
  switch (outMode) {
    case 'P2PKH':
      mLtcTxOut0.setP2pkhPkhash(toAddrContent);
      break;
    case 'P2SH':
      mLtcTxOut0.setP2shShash(toAddrContent);
      break;
    case 'P2WPKH':
      mLtcTxOut0.setP2pkhPkhash(toAddrContent);
      break;
    case 'P2WSH':
      mLtcTxOut0.setP2wshShash(toAddrContent);
      break;
    default:
      throw Error('control reaches a point which shall be unreachable');
  }
  mLtcSignTx.setOutputsList(
    chgAmount > 0 ? [mLtcTxOut0, mLtcTxOut1] : [mLtcTxOut0]
  );

  const mLtcCommand = new LtcCommand();
  mLtcCommand.setMode(LtcCommand.LtcMode.P2SH_P2WPKH);
  mLtcCommand.setTestnet(req.network === 'testnet');
  mLtcCommand.setSignTx(mLtcSignTx);

  const satoshisToKelvinWalletAmount = (s: string): string =>
    truncateToSixDecimals(convertBaseAmountToNormAmount(s));

  return [
    {
      commandId: LITECOIN_CMDID,
      payload: Buffer.from(mLtcCommand.serializeBinary()),
    },
    {
      to: { value: toAddr },
      amount: { value: satoshisToKelvinWalletAmount('' + satoshiAmount) },
      fee: { value: satoshisToKelvinWalletAmount('' + feeAmount) },
    },
  ];
}

function buildSignedTx(
  req: ISignTxRequest,
  preparedTx: IArmadilloCommand,
  walletRsp: IArmadilloResponse
): string {
  // although unnecessary, we may still validate `req`
  validateSignTxRequest(req);

  // although unnecessary, we may still validate `preparedTx`
  validatePreparedTx(preparedTx);

  const rsp = w('Invalid wallet response: bad LtcResponse encoding', () =>
    LtcResponse.deserializeBinary(walletRsp.payload)
  );

  const signedTxObj = rsp.getSignedTx();
  if (signedTxObj === undefined) {
    if (rsp.hasError()) {
      throw Error(`Unexpected wallet errorCode response: ${rsp.getError()}`);
    }
    throw Error('Unexpected wallet response');
  }

  return Buffer.from(signedTxObj.getRawtx_asU8()).toString('hex');
}

async function submitTransaction(
  network: string,
  signedTx: string
): Promise<string> {
  if (!['mainnet', 'testnet'].includes(network)) {
    throw Error(`invalid network: ${network}`);
  }

  if (!isValidHexString(signedTx)) {
    throw Error(`invalid signedTx: ${signedTx}`);
  }

  if (network === 'mainnet') {
    // https://www.blockcypher.com/dev/bitcoin/#push-raw-transaction-endpoint
    const { statusCode, payload } = await performMyPost({
      endpoint: 'https://api.blockcypher.com',
      path: '/v1/ltc/main/txs/push',
      timeoutMs: 5000,
      payload: { tx: signedTx },
    });

    if (statusCode === 400) {
      // 1. provided tx is invalid
      // 2. provided tx already exists in mempool
      // 3. provided tx already exists in blockchain
      if (
        ((x: unknown): x is { error: string } =>
          isObject(x) && isString(x.error))(payload)
      ) {
        throw Error(payload.error);
      }
      throw Error('API server api.blockcypher.com reports 400');
    }

    if (statusCode !== 201) {
      throw Error(`unexpected HTTP statusCode: ${statusCode}`);
    }

    if (
      !((x: unknown): x is { hash: string } =>
        isObject(x) && isValidTransactionId(x.hash))(payload)
    ) {
      throw Error(`unexpected HTTP response: ${payload}`);
    }

    return payload.hash;
  } else {
    // See the "Transaction Broadcasting" section of this document:
    // https://github.com/litecoin-project/insight-lite-api/tree/dc7cc4f8
    const { statusCode, payload } = await performMyPost({
      endpoint: 'https://testnet.litecore.io',
      path: '/api/tx/send',
      timeoutMs: 5000,
      payload: { rawtx: signedTx },
    });

    if (statusCode === 400) {
      throw Error('Got HTTP 400 Bad Request from API server');
    }

    if (statusCode !== 200) {
      throw Error(`unexpected HTTP statusCode: ${statusCode}`);
    }

    if (
      !((x: unknown): x is { txid: string } =>
        isObject(x) && isValidTransactionId(x.txid))(payload)
    ) {
      throw Error(`unexpected HTTP response: ${payload}`);
    }

    return payload.txid;
  }
}

function prepareCommandGetPubkey(
  network: string,
  accountIndex: number
): IArmadilloCommand {
  if (!['mainnet', 'testnet'].includes(network)) {
    throw Error(`invalid network: ${network}`);
  }

  if (!(isNonNegativeInteger(accountIndex) && accountIndex <= 0x7fffffff)) {
    throw Error(`invalid accountIndex: ${accountIndex}`);
  }

  const mLtcGetXPub = new LtcGetXPub();
  mLtcGetXPub.setPathList([2 ** 31 + accountIndex, 0, 0]);

  const mLtcCommand = new LtcCommand();
  mLtcCommand.setMode(LtcCommand.LtcMode.P2SH_P2WPKH);
  mLtcCommand.setTestnet(network === 'testnet');
  mLtcCommand.setGetXpub(mLtcGetXPub);

  return {
    commandId: LITECOIN_CMDID,
    payload: Buffer.from(mLtcCommand.serializeBinary()),
  };
}

function parsePubkeyResponse(walletRsp: IArmadilloResponse): string {
  const rsp = w('Invalid wallet response: bad LtcResponse encoding', () =>
    LtcResponse.deserializeBinary(walletRsp.payload)
  );

  const xpubObj = rsp.getXpub();
  if (xpubObj === undefined) {
    if (rsp.hasError()) {
      throw Error(`Unexpected wallet errorCode response: ${rsp.getError()}`);
    }
    throw Error('Unexpected wallet response');
  }

  return (
    '04' +
    Buffer.from(xpubObj.getXpub_asU8())
      .slice(0, 64)
      .toString('hex')
  );
}

function prepareCommandShowAddr(
  network: string,
  accountIndex: number
): IArmadilloCommand {
  if (!['mainnet', 'testnet'].includes(network)) {
    throw Error(`invalid network: ${network}`);
  }

  if (!(isNonNegativeInteger(accountIndex) && accountIndex <= 0x7fffffff)) {
    throw Error(`invalid accountIndex: ${accountIndex}`);
  }

  const mLtcShowAddr = new LtcShowAddr();
  mLtcShowAddr.setPathList([2 ** 31 + accountIndex, 0, 0]);

  const mLtcCommand = new LtcCommand();
  mLtcCommand.setMode(LtcCommand.LtcMode.P2SH_P2WPKH);
  mLtcCommand.setTestnet(network === 'testnet');
  mLtcCommand.setShowAddr(mLtcShowAddr);

  return {
    commandId: LITECOIN_CMDID,
    payload: Buffer.from(mLtcCommand.serializeBinary()),
  };
}

// ---------------------------------------------------------------------------

export const ltcCurrencyUtil: ICurrencyUtil = {
  getSupportedNetworks,
  getFeeOptionUnit,
  isValidFeeOption,
  isValidAddr,
  isValidNormAmount,
  convertNormAmountToBaseAmount,
  convertBaseAmountToNormAmount,
  getUrlForAddr,
  getUrlForTx,
  encodePubkeyToAddr,
  getBalance,
  getHistorySchema,
  getRecentHistory,
  getFeeOptions,
  getPreparedTxSchema,
  prepareCommandSignTx,
  buildSignedTx,
  submitTransaction,
  prepareCommandGetPubkey,
  parsePubkeyResponse,
  prepareCommandShowAddr,
};

export default ltcCurrencyUtil;
